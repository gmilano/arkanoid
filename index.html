<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ§± Arkanoid</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #050510;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  user-select: none;
}
#hud {
  display: flex;
  justify-content: space-between;
  width: 100%;
  max-width: 480px;
  padding: 6px 4px;
  color: #fff;
  font-size: 13px;
  letter-spacing: 1px;
}
.score-val { color: #4ff; text-shadow: 0 0 8px #4ff; }
.lives-val { color: #f84; }
.level-val { color: #ff4; text-shadow: 0 0 8px #ff4; }
canvas {
  display: block;
  border: 1px solid rgba(100,150,255,0.15);
  box-shadow: 0 0 60px rgba(60,120,255,0.15);
}
</style>
</head>
<body>
<div id="hud">
  <span>SCORE: <span class="score-val" id="scoreDisplay">0</span></span>
  <span>LEVEL: <span class="level-val" id="levelDisplay">1</span></span>
  <span>LIVES: <span class="lives-val" id="livesDisplay">â¤ï¸â¤ï¸â¤ï¸</span></span>
</div>
<canvas id="gameCanvas"></canvas>
<script>
// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CW = 480, CH = 640;
const BALL_R = 7;
const ROWS = 8, COLS = 10;
const BM = 4; // brick margin

// Brick type colors [normal, highlight, shadow]
const BRICK_COLORS = {
  1: ['#2288ff','#66bbff','#0044aa'],
  2: ['#ff6622','#ffaa66','#aa2200'],
  3: ['#556677','#889aaa','#334455'],
};

const LEVELS = [
  { speed: 4.0, paddleW: 92, pattern: [
    [1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1],
    [1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
  ]},
  { speed: 4.6, paddleW: 84, pattern: [
    [2,1,1,1,1,1,1,1,1,2],
    [1,2,1,1,1,1,1,1,2,1],
    [1,1,2,1,1,1,1,2,1,1],
    [1,1,1,2,2,2,2,1,1,1],
    [1,1,1,2,2,2,2,1,1,1],
    [1,1,2,1,1,1,1,2,1,1],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
  ]},
  { speed: 5.2, paddleW: 78, pattern: [
    [3,3,3,3,3,3,3,3,3,3],
    [2,2,2,2,2,2,2,2,2,2],
    [1,1,1,1,1,1,1,1,1,1],
    [1,2,1,2,1,2,1,2,1,2],
    [2,1,2,1,2,1,2,1,2,1],
    [1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
  ]},
  { speed: 5.8, paddleW: 72, pattern: [
    [3,1,3,1,3,1,3,1,3,1],
    [1,3,1,3,1,3,1,3,1,3],
    [2,2,2,2,2,2,2,2,2,2],
    [1,1,1,1,1,1,1,1,1,1],
    [1,2,2,1,1,1,1,2,2,1],
    [1,1,1,2,3,3,2,1,1,1],
    [2,2,2,2,2,2,2,2,2,2],
    [0,0,0,0,0,0,0,0,0,0],
  ]},
  { speed: 6.5, paddleW: 65, pattern: [
    [3,3,2,2,1,1,2,2,3,3],
    [3,2,2,1,1,1,1,2,2,3],
    [2,2,1,1,3,3,1,1,2,2],
    [2,1,1,3,2,2,3,1,1,2],
    [2,1,1,3,2,2,3,1,1,2],
    [2,2,1,1,3,3,1,1,2,2],
    [3,2,2,1,1,1,1,2,2,3],
    [3,3,2,2,1,1,2,2,3,3],
  ]},
];

// â”€â”€ CANVAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
  const sc = Math.min((innerWidth - 16) / CW, (innerHeight - 60) / CH, 1);
  canvas.width = CW; canvas.height = CH;
  canvas.style.width  = (CW * sc) + 'px';
  canvas.style.height = (CH * sc) + 'px';
}
resize();
window.addEventListener('resize', resize);

// â”€â”€ AUDIO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let AC = null;
function ac() { if (!AC) AC = new (AudioContext || webkitAudioContext)(); return AC; }

function sound(type) {
  try {
    const a = ac(), o = a.createOscillator(), g = a.createGain();
    o.connect(g); g.connect(a.destination);
    const t = a.currentTime;
    const cfg = {
      paddle:  [o => { o.frequency.setValueAtTime(220,t); o.frequency.exponentialRampToValueAtTime(360,t+.08); }, g => { g.gain.setValueAtTime(.15,t); g.gain.exponentialRampToValueAtTime(.001,t+.1); }, .1, 'sine'],
      wall:    [o => { o.frequency.setValueAtTime(160,t); }, g => { g.gain.setValueAtTime(.08,t); g.gain.exponentialRampToValueAtTime(.001,t+.05); }, .05, 'sine'],
      brick:   [o => { o.frequency.setValueAtTime(480,t); o.frequency.exponentialRampToValueAtTime(200,t+.07); }, g => { g.gain.setValueAtTime(.12,t); g.gain.exponentialRampToValueAtTime(.001,t+.08); }, .08, 'square'],
      powerup: [o => { o.frequency.setValueAtTime(440,t); o.frequency.exponentialRampToValueAtTime(880,t+.2); }, g => { g.gain.setValueAtTime(.18,t); g.gain.exponentialRampToValueAtTime(.001,t+.25); }, .25, 'sine'],
      die:     [o => { o.frequency.setValueAtTime(300,t); o.frequency.exponentialRampToValueAtTime(50,t+.55); }, g => { g.gain.setValueAtTime(.2,t); g.gain.exponentialRampToValueAtTime(.001,t+.55); }, .55, 'sawtooth'],
      laser:   [o => { o.frequency.setValueAtTime(900,t); o.frequency.exponentialRampToValueAtTime(200,t+.12); }, g => { g.gain.setValueAtTime(.1,t); g.gain.exponentialRampToValueAtTime(.001,t+.12); }, .12, 'sawtooth'],
    };
    if (type === 'levelup') {
      [523,659,784,1047].forEach((f,i) => {
        const o2=a.createOscillator(), g2=a.createGain();
        o2.connect(g2); g2.connect(a.destination);
        o2.frequency.value=f;
        g2.gain.setValueAtTime(.15,t+i*.12);
        g2.gain.exponentialRampToValueAtTime(.001,t+i*.12+.18);
        o2.start(t+i*.12); o2.stop(t+i*.12+.2);
      });
      return;
    }
    const [fo,fg,dur,wt] = cfg[type] || [];
    if (!fo) return;
    o.type = wt;
    fo(o); fg(g);
    o.start(); o.stop(t + dur);
  } catch(e) {}
}

// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const S = { START:0, PLAY:1, PAUSE:2, LVLDONE:3, OVER:4, WIN:5 };
let state = S.START;
let score = 0, lives = 3, lvlIdx = 0;
let hs = +localStorage.getItem('ark_hs') || 0;

// â”€â”€ OBJECTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let paddle = { x:0, y: CH-42, w:92, h:12 };
let balls = [], bricks = [], powerups = [], lasers = [], particles = [];
let wideT=0, slowT=0, laserT=0, laserOn=false;

function mkBall(x,y,vx,vy) { return {x,y,vx,vy,trail:[]}; }

function loadLevel() {
  const L = LEVELS[lvlIdx];
  paddle.w = L.paddleW;
  paddle.x = CW/2 - paddle.w/2;
  balls = [mkBall(CW/2, CH-82, (Math.random()>.5?1:-1)*2.8, -L.speed)];
  bricks = [];
  powerups=[]; lasers=[]; particles=[];
  wideT=0; slowT=0; laserT=0; laserOn=false;

  const bW = (CW - BM*(COLS+1)) / COLS, bH = 22;
  for (let r=0; r<ROWS; r++) {
    for (let c=0; c<COLS; c++) {
      const tp = L.pattern[r][c];
      if (!tp) continue;
      bricks.push({
        x: BM + c*(bW+BM), y: 58 + r*(bH+BM),
        w: bW, h: bH, type: tp,
        hp: tp===2?2: tp===3?Infinity:1,
        maxHp: tp===2?2: tp===3?Infinity:1,
        flash: 0,
      });
    }
  }
  hud();
}

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys = {};
let mouseX = CW/2;

document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (['Enter',' '].includes(e.key)) onAction();
  if (['p','P','Escape'].includes(e.key)) onPause();
  e.preventDefault && ['ArrowLeft','ArrowRight',' '].includes(e.key) && e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

function trackMouse(clientX) {
  const r = canvas.getBoundingClientRect();
  mouseX = (clientX - r.left) * (CW / r.width);
}
canvas.addEventListener('mousemove', e => trackMouse(e.clientX));
canvas.addEventListener('click', () => onAction());
canvas.addEventListener('touchmove', e => { e.preventDefault(); trackMouse(e.touches[0].clientX); }, {passive:false});
canvas.addEventListener('touchstart', e => { e.preventDefault(); trackMouse(e.touches[0].clientX); onAction(); }, {passive:false});

function onAction() {
  if (state === S.START || state === S.OVER || state === S.WIN) {
    score=0; lives=3; lvlIdx=0; loadLevel(); state=S.PLAY;
  } else if (state === S.LVLDONE) {
    lvlIdx++;
    if (lvlIdx >= LEVELS.length) { state=S.WIN; if(score>hs){hs=score;localStorage.setItem('ark_hs',hs);} }
    else { loadLevel(); state=S.PLAY; }
  } else if (state === S.PLAY && laserOn) {
    fireLaser();
  }
}
function onPause() {
  if (state===S.PLAY) state=S.PAUSE;
  else if (state===S.PAUSE) state=S.PLAY;
}

// â”€â”€ POWERUPS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PU = {
  wide:  { col:'#00ee44', lbl:'WIDE',  dur:480 },
  multi: { col:'#ee44ff', lbl:'MULTI', dur:0 },
  slow:  { col:'#00ccff', lbl:'SLOW',  dur:420 },
  laser: { col:'#ff2222', lbl:'LASER', dur:500 },
  life:  { col:'#ff8844', lbl:'LIFE',  dur:0 },
};
const PU_KEYS = Object.keys(PU);

function trySpawnPU(x, y) {
  if (Math.random() > .22) return;
  const tp = PU_KEYS[Math.floor(Math.random()*PU_KEYS.length)];
  powerups.push({ x: x-14, y, w:28, h:14, vy:1.8, type:tp, anim:0 });
}

function applyPU(type) {
  sound('powerup');
  spawnParticles(paddle.x+paddle.w/2, paddle.y, PU[type].col, 22);
  if (type==='wide')  { wideT = PU.wide.dur; }
  if (type==='slow')  { slowT = PU.slow.dur; }
  if (type==='laser') { laserOn=true; laserT = PU.laser.dur; }
  if (type==='life')  { lives=Math.min(lives+1,5); hud(); }
  if (type==='multi') {
    const nb = [];
    balls.forEach(b => {
      nb.push(mkBall(b.x,b.y, -b.vx*1.05, b.vy));
      nb.push(mkBall(b.x,b.y,  b.vx*0.9, b.vy*1.1));
    });
    balls.push(...nb);
  }
}

function fireLaser() {
  sound('laser');
  lasers.push({ x: paddle.x+8,       y: paddle.y, w:3, h:14, vy:-12 });
  lasers.push({ x: paddle.x+paddle.w-11, y: paddle.y, w:3, h:14, vy:-12 });
}

// â”€â”€ PARTICLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(x, y, col, n=12) {
  for (let i=0; i<n; i++) {
    const a = Math.random()*Math.PI*2, sp = 1.5+Math.random()*4;
    particles.push({ x, y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp-1,
      r:1.5+Math.random()*3, life:1, dec:.025+Math.random()*.04, col });
  }
}

// â”€â”€ UPDATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  if (state !== S.PLAY) return;

  // Paddle
  const targetW = wideT>0 ? Math.min(LEVELS[lvlIdx].paddleW*1.65, CW-20) : LEVELS[lvlIdx].paddleW;
  paddle.w += (targetW - paddle.w) * 0.15;
  if (keys['ArrowLeft'])  mouseX -= 7;
  if (keys['ArrowRight']) mouseX += 7;
  paddle.x = Math.max(0, Math.min(CW - paddle.w, mouseX - paddle.w/2));

  // Timers
  if (wideT > 0) wideT--;
  if (slowT > 0) slowT--;
  if (laserT > 0) { laserT--; if (!laserT) laserOn=false; }

  const sm = slowT>0 ? 0.52 : 1;

  // Balls
  for (let i=balls.length-1; i>=0; i--) {
    const b = balls[i];
    b.trail.push({x:b.x, y:b.y});
    if (b.trail.length > 9) b.trail.shift();

    b.x += b.vx * sm;
    b.y += b.vy * sm;

    // Walls
    if (b.x - BALL_R < 0) { b.x=BALL_R; b.vx=Math.abs(b.vx); sound('wall'); }
    if (b.x + BALL_R > CW) { b.x=CW-BALL_R; b.vx=-Math.abs(b.vx); sound('wall'); }
    if (b.y - BALL_R < 0) { b.y=BALL_R; b.vy=Math.abs(b.vy); sound('wall'); }

    // Paddle
    if (b.vy > 0 &&
        b.x > paddle.x - BALL_R && b.x < paddle.x + paddle.w + BALL_R &&
        b.y + BALL_R >= paddle.y && b.y - BALL_R <= paddle.y + paddle.h) {
      const hit = (b.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
      const ang = hit * (Math.PI/3.2);
      const sp = Math.hypot(b.vx, b.vy);
      b.vx = Math.sin(ang) * sp;
      b.vy = -Math.abs(Math.cos(ang) * sp);
      b.y = paddle.y - BALL_R;
      sound('paddle');
    }

    // Bricks
    for (let j=bricks.length-1; j>=0; j--) {
      const br = bricks[j];
      if (b.x+BALL_R > br.x && b.x-BALL_R < br.x+br.w &&
          b.y+BALL_R > br.y && b.y-BALL_R < br.y+br.h) {
        const ol = b.x+BALL_R - br.x, or2 = br.x+br.w - (b.x-BALL_R);
        const ot = b.y+BALL_R - br.y, ob  = br.y+br.h - (b.y-BALL_R);
        const mn = Math.min(ol,or2,ot,ob);
        if (mn===ol||mn===or2) b.vx*=-1; else b.vy*=-1;
        hitBrick(j);
        break;
      }
    }

    // Lost
    if (b.y - BALL_R > CH) {
      balls.splice(i, 1);
      if (!balls.length) loseLife();
    }
  }

  // Lasers
  for (let i=lasers.length-1; i>=0; i--) {
    lasers[i].y += lasers[i].vy;
    if (lasers[i].y < -20) { lasers.splice(i,1); continue; }
    for (let j=bricks.length-1; j>=0; j--) {
      const br=bricks[j], la=lasers[i];
      if (!la) break;
      if (la.x < br.x+br.w && la.x+la.w > br.x &&
          la.y < br.y+br.h && la.y+la.h > br.y) {
        if (br.type!==3) hitBrick(j);
        lasers.splice(i,1);
        break;
      }
    }
  }

  // Powerups
  for (let i=powerups.length-1; i>=0; i--) {
    const p=powerups[i]; p.y+=p.vy; p.anim++;
    if (p.y > CH) { powerups.splice(i,1); continue; }
    if (p.x < paddle.x+paddle.w && p.x+p.w > paddle.x &&
        p.y < paddle.y+paddle.h && p.y+p.h > paddle.y) {
      applyPU(p.type); powerups.splice(i,1);
    }
  }

  // Particles
  for (let i=particles.length-1; i>=0; i--) {
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.1;
    p.life-=p.dec;
    if (p.life<=0) particles.splice(i,1);
  }

  // Level clear
  if (!bricks.some(b => b.type!==3)) {
    sound('levelup');
    state = S.LVLDONE;
  }
}

function hitBrick(j) {
  const br = bricks[j];
  if (br.type === 3) { br.flash=6; sound('wall'); return; }
  br.hp--; br.flash=9;
  sound('brick');
  if (br.hp <= 0) {
    spawnParticles(br.x+br.w/2, br.y+br.h/2, BRICK_COLORS[br.type][0], 14);
    trySpawnPU(br.x+br.w/2, br.y+br.h/2);
    score += br.type===2 ? 20 : 10;
    hud();
    bricks.splice(j,1);
  }
}

function loseLife() {
  lives--;
  hud();
  sound('die');
  if (lives <= 0) {
    state = S.OVER;
    if (score>hs) { hs=score; localStorage.setItem('ark_hs',hs); }
  } else {
    const L=LEVELS[lvlIdx];
    balls = [mkBall(CW/2, CH-82, (Math.random()>.5?1:-1)*2.8, -L.speed)];
    wideT=0; slowT=0; laserT=0; laserOn=false;
    paddle.w = L.paddleW;
  }
}

// â”€â”€ DRAW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  // Background
  const bg = ctx.createLinearGradient(0,0,0,CH);
  bg.addColorStop(0,'#080820');
  bg.addColorStop(1,'#050510');
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,CW,CH);

  // Grid
  ctx.strokeStyle='rgba(80,100,255,0.045)';
  ctx.lineWidth=1;
  for(let x=0;x<CW;x+=32){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,CH);ctx.stroke();}
  for(let y=0;y<CH;y+=32){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(CW,y);ctx.stroke();}

  drawBricks();
  drawPowerups();
  drawLasers();
  drawPaddle();
  drawBalls();
  drawParticles();
  drawStatus();

  // Overlays
  if (state===S.START)    overlay('ARKANOID','Press Enter or tap to play',`Best: ${hs}`);
  if (state===S.PAUSE)    overlay('PAUSED','P / Esc to resume','');
  if (state===S.LVLDONE)  overlay(`LEVEL ${lvlIdx+1} CLEAR!','Score: '+score,'Tap to continue');
  if (state===S.OVER)     overlay('GAME OVER',`Score: ${score}  Â·  Best: ${hs}`,'Tap to retry');
  if (state===S.WIN)      overlay('ğŸ‰ YOU WIN!',`Score: ${score}  Â·  Best: ${hs}`,'Tap to play again');
}

function drawBricks() {
  bricks.forEach(br => {
    const fl = br.flash>0 && br.flash%2===0;
    br.flash = Math.max(0, br.flash-1);
    const cols = BRICK_COLORS[br.type];
    ctx.save();
    ctx.shadowBlur = fl ? 22 : 9;
    ctx.shadowColor = fl ? '#fff' : cols[0];
    const g = ctx.createLinearGradient(br.x,br.y,br.x,br.y+br.h);
    g.addColorStop(0, fl?'#fff':cols[1]);
    g.addColorStop(1, fl?'#888':cols[2]);
    ctx.fillStyle=g;
    ctx.beginPath(); ctx.roundRect(br.x,br.y,br.w,br.h,3); ctx.fill();
    // Shine
    const sh=ctx.createLinearGradient(br.x,br.y,br.x,br.y+br.h*.5);
    sh.addColorStop(0,'rgba(255,255,255,0.18)');
    sh.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=sh;
    ctx.beginPath(); ctx.roundRect(br.x+1,br.y+1,br.w-2,br.h*.5,[3,3,0,0]); ctx.fill();
    // Crack for damaged hard bricks
    if (br.type===2 && br.hp < br.maxHp) {
      ctx.strokeStyle='rgba(0,0,0,0.55)'; ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.moveTo(br.x+br.w*.28,br.y+2);
      ctx.lineTo(br.x+br.w*.52,br.y+br.h*.55);
      ctx.lineTo(br.x+br.w*.72,br.y+br.h-2);
      ctx.stroke();
    }
    ctx.restore();
  });
}

function drawPaddle() {
  const {x,y,w,h}=paddle;
  const col = laserOn?'#ff4444': wideT>0?'#44ff66':'#44aaff';
  ctx.save();
  ctx.shadowBlur=18; ctx.shadowColor=col;
  const g=ctx.createLinearGradient(x,y,x,y+h);
  g.addColorStop(0, laserOn?'#ff9999': wideT>0?'#99ffaa':'#99ddff');
  g.addColorStop(1, laserOn?'#880000': wideT>0?'#006622':'#004488');
  ctx.fillStyle=g;
  ctx.beginPath(); ctx.roundRect(x,y,w,h,6); ctx.fill();
  // Shine
  const sh=ctx.createLinearGradient(x,y,x,y+h*.5);
  sh.addColorStop(0,'rgba(255,255,255,0.3)');
  sh.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle=sh;
  ctx.beginPath(); ctx.roundRect(x+1,y+1,w-2,h*.5,[5,5,0,0]); ctx.fill();
  ctx.restore();
}

function drawBalls() {
  balls.forEach(b => {
    b.trail.forEach((t,i) => {
      const a=(i/b.trail.length)*.45, r=BALL_R*(i/b.trail.length)*.8;
      ctx.save(); ctx.globalAlpha=a;
      ctx.fillStyle='#55aaff';
      ctx.beginPath(); ctx.arc(t.x,t.y,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    });
    ctx.save();
    ctx.shadowBlur=22; ctx.shadowColor='#44bbff';
    const g=ctx.createRadialGradient(b.x-2,b.y-2,1,b.x,b.y,BALL_R);
    g.addColorStop(0,'#fff');
    g.addColorStop(.4,'#88ddff');
    g.addColorStop(1,'#0044aa');
    ctx.fillStyle=g;
    ctx.beginPath(); ctx.arc(b.x,b.y,BALL_R,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });
}

function drawPowerups() {
  powerups.forEach(p => {
    const {col,lbl}=PU[p.type];
    ctx.save();
    ctx.shadowBlur=12; ctx.shadowColor=col;
    ctx.fillStyle=col;
    ctx.beginPath(); ctx.roundRect(p.x,p.y,p.w,p.h,4); ctx.fill();
    ctx.fillStyle='#000';
    ctx.font='bold 10px monospace';
    ctx.textAlign='center';
    ctx.fillText(lbl, p.x+p.w/2, p.y+p.h-3);
    ctx.restore();
  });
}

function drawLasers() {
  lasers.forEach(l => {
    ctx.save();
    ctx.shadowBlur=12; ctx.shadowColor='#ff4444';
    ctx.fillStyle='#ff8888';
    ctx.fillRect(l.x,l.y,l.w,l.h);
    ctx.restore();
  });
}

function drawParticles() {
  particles.forEach(p => {
    ctx.save();
    ctx.globalAlpha=p.life;
    ctx.fillStyle=p.col;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r*p.life,0,Math.PI*2); ctx.fill();
    ctx.restore();
  });
}

function drawStatus() {
  const bits = [];
  if (wideT>0) bits.push(`W:${Math.ceil(wideT/60)}s`);
  if (slowT>0) bits.push(`S:${Math.ceil(slowT/60)}s`);
  if (laserOn) bits.push(`L:${Math.ceil(laserT/60)}s`);
  if (!bits.length) return;
  ctx.save();
  ctx.font='11px monospace'; ctx.fillStyle='rgba(100,255,150,0.9)'; ctx.textAlign='right';
  ctx.fillText(bits.join('  '), CW-8, CH-8);
  ctx.restore();
}

function overlay(title, line1='', line2='') {
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.78)';
  ctx.fillRect(0,0,CW,CH);
  ctx.textAlign='center';
  // Title
  ctx.shadowBlur=40; ctx.shadowColor='#4488ff';
  ctx.fillStyle='#ffffff';
  ctx.font='bold 44px monospace';
  ctx.fillText(title, CW/2, CH/2-28);
  // Line1
  ctx.shadowBlur=0;
  ctx.fillStyle='#aaccff';
  ctx.font='17px monospace';
  ctx.fillText(line1, CW/2, CH/2+18);
  // Line2
  ctx.fillStyle='#667799';
  ctx.font='13px monospace';
  ctx.fillText(line2, CW/2, CH/2+48);
  ctx.restore();
}

// â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function hud() {
  document.getElementById('scoreDisplay').textContent = score;
  document.getElementById('levelDisplay').textContent = lvlIdx+1;
  document.getElementById('livesDisplay').textContent = 'â¤ï¸'.repeat(lives);
}

// â”€â”€ LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

hud();
loop();
</script>
</body>
</html>
